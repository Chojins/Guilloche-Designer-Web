<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Guilloche Pattern Generator</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        font-family: Arial, sans-serif;
    }

    h1 {
        width: 100%;
        text-align: center;
        margin: 20px 0;
        font-size: 2em;
    }

    .container {
        display: flex;
        align-items: flex-start; /* Aligns controls to the top of the canvas */
        gap: 20px;
        width: 90%;
    }

    .controls {
        display: flex;
        flex-direction: column;
        width: 300px;
        max-width: 300px;
    }

    .control-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .control-group label {
        width: 120px;
    }

    .control-group input {
        width: 60px;
        margin-right: 5px;
    }

    .control-group button {
        margin: 0 2px;
    }

    #canvasContainer {
        flex: 1;
    }

    /* Style for the canvas */
    #patternCanvas {
        border: 1px solid #ccc;
    }

    #svgContainer {
        flex: 0 0 600px;
        width: 600px;
        height: 600px;
        border: 1px solid black;
    }

    #svgContainer svg {
        width: 100%;
        height: 100%;
        background-color: white;
    }

</style>
</head>
<body>

<h1>Guilloche Pattern Generator</h1>

<div class="container">
    <div class="controls">
        <div class="control-group">
                <label for="m1centerx">M1 center x:</label>
                <input type="number" id="m1centerx" value="0" step="1" />
                <button data-id="m1centerx" data-delta="1">+</button>
                <button data-id="m1centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m1centery">M1 center y:</label>
                <input type="number" id="m1centery" value="600" step="1" />
                <button data-id="m1centery" data-delta="1">+</button>
                <button data-id="m1centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M1Period">M1 Period:</label>
                <input type="number" id="M1Period" value="299" step="1" />
                <button data-id="M1Period" data-delta="1">+</button>
                <button data-id="M1Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m2centerx">M2 center x:</label>
                <input type="number" id="m2centerx" value="210" step="1" />
                <button data-id="m2centerx" data-delta="1">+</button>
                <button data-id="m2centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m2centery">M2 center y:</label>
                <input type="number" id="m2centery" value="600" step="1" />
                <button data-id="m2centery" data-delta="1">+</button>
                <button data-id="m2centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M2Period">M2 Period:</label>
                <input type="number" id="M2Period" value="302" step="1" />
                <button data-id="M2Period" data-delta="1">+</button>
                <button data-id="M2Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m3centerx">M3 center x:</label>
                <input type="number" id="m3centerx" value="0" step="1" />
                <button data-id="m3centerx" data-delta="1">+</button>
                <button data-id="m3centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m3centery">M3 center y:</label>
                <input type="number" id="m3centery" value="260" step="1" />
                <button data-id="m3centery" data-delta="1">+</button>
                <button data-id="m3centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M3Period">M3 Period:</label>
                <input type="number" id="M3Period" value="600" step="1" />
                <button data-id="M3Period" data-delta="1">+</button>
                <button data-id="M3Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="Iterations">Iterations:</label>
                <input type="number" id="Iterations" value="20000" step="10" />
                <button data-id="Iterations" data-delta="10">+</button>
                <button data-id="Iterations" data-delta="-10">-</button>
            </div>
            <div class="control-group">
                <label for="aLength">aLength:</label>
                <input type="number" id="aLength" value="30" />
                <button data-id="aLength" data-delta="1">+</button>
                <button data-id="aLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="bLength">bLength:</label>
                <input type="number" id="bLength" value="340" />
                <button data-id="bLength" data-delta="1">+</button>
                <button data-id="bLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="cLength">cLength:</label>
                <input type="number" id="cLength" value="400" />
                <button data-id="cLength" data-delta="1">+</button>
                <button data-id="cLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="dLength">dLength:</label>
                <input type="number" id="dLength" value="30" />
                <button data-id="dLength" data-delta="1">+</button>
                <button data-id="dLength" data-delta="-1">-</button>
            </div>
        
            <div class="control-group">
                <button id="generateButton">Generate Pattern</button>
            </div>

            <div class="control-group">
                <button id="saveButton">Save SVG</button>
                <button id="loadButton">Load SVG</button>
                <input type="file" id="fileInput" accept=".svg" style="display: none;">
            </div>
        </div>
    
        <!-- Placeholder for dynamically generated SVG -->
        <div id="svgContainer"></div>

    </div>

    <script>

        let offsetX = 0, offsetY = 0; // Initial canvas position offset
        let scale = 1; // Initial zoom scale
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // Add these as global variables at the start of the script section
        let globalScale = 1;
        let globalShiftX = 0;
        let globalShiftY = 0;
        let isFirstRender = true;

        document.getElementById("generateButton").addEventListener("click", generatePattern);

        function adjustValue(id, delta) {
            const input = document.getElementById(id);
            input.value = parseFloat(input.value) + delta;
            generatePattern();
        }

        document.querySelectorAll('.control-group button').forEach(button => {
            const id = button.getAttribute('data-id');
            const delta = parseFloat(button.getAttribute('data-delta'));
            
            let isAdjusting = false;
            let lastUpdateTime = 0;
            const updateInterval = 100; // Faster repeat rate (10 times per second)
            let animationFrameId = null;
            let holdStartTime = 0;
            const holdDelay = 500; // Keep 500ms delay before starting continuous updates

            function updateValue(timestamp) {
                if (isAdjusting) {
                    // Only start continuous updates after holding for holdDelay
                    if (timestamp - holdStartTime >= holdDelay) {
                        // Then only update if enough time has passed
                        if (timestamp - lastUpdateTime >= updateInterval) {
                            adjustValue(id, delta);
                            lastUpdateTime = timestamp;
                        }
                        animationFrameId = requestAnimationFrame(updateValue);
                    } else {
                        animationFrameId = requestAnimationFrame(updateValue);
                    }
                }
            }

            button.addEventListener('mousedown', () => {
                isAdjusting = true;
                holdStartTime = performance.now();
                lastUpdateTime = 0;
                // Immediate single adjustment on click
                adjustValue(id, delta);
                // Start watching for hold
                updateValue(performance.now());
            });

            const stopAdjusting = () => {
                isAdjusting = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            };

            button.addEventListener('mouseup', stopAdjusting);
            button.addEventListener('mouseleave', stopAdjusting);
            window.addEventListener('mouseup', stopAdjusting);
        });

        function generatePattern() {
            // Clear the isFirstRender flag at the start
            isFirstRender = true;
            parameters = getParameters();
            displayPatternAsSVG(parameters);
        }

        // Add this after the generatePattern function
        // Add enter key handler to all input fields
        document.querySelectorAll('.controls input').forEach(input => {
            input.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    generatePattern();
                }
            });
        });

        function displayPatternAsSVG(parameters) {
            // Add console log to debug
            console.log('Generating SVG with parameters:', parameters);

            // Generate SVG content
            const svgContent = generateSVGContent(parameters);
            console.log('SVG content generated:', svgContent.substring(0, 100) + '...'); // Log first 100 chars

            // Replace canvas with SVG
            const svgContainer = document.getElementById("svgContainer");
            svgContainer.innerHTML = svgContent;
        }

        // Function to generate the Guilloche pattern and return the points
        function generatePatternPoints(params) {

            let XPointList = [];
            let YPointList = [];
            let t = 0;

            // Periodic motors' calculations and drawing
            for (let i = 0; i < params.Iterations; i++) {
                
                const theta2 = 2 * Math.PI * (t / params.M1Period);

                const mdist = Math.sqrt(Math.pow(params.m2centerx - params.m1centerx, 2) + Math.pow(params.m2centery - params.m1centery, 2));

                const k1 = mdist / params.aLength;
                const k2 = mdist / params.cLength;
                const k3 = (Math.pow(params.aLength, 2) + Math.pow(params.cLength, 2) + Math.pow(mdist, 2) - Math.pow(params.bLength, 2)) / (2 * params.aLength * params.cLength);
                
                //calculate the motor positions
                const m1x = params.aLength * Math.cos(theta2) + params.m1centerx;
                const m1y = params.aLength * Math.sin(theta2) + params.m1centery;
                const m2x = -params.dLength * Math.cos(2 * Math.PI * (t / params.M2Period)) + params.m2centerx;
                const m2y = -params.dLength * Math.sin(2 * Math.PI * (t / params.M2Period)) + params.m2centery;


                // Calculate linkage
                const Cterm = k1 - (k2 + 1) * Math.cos(theta2) + k3;
                const Bterm = -2 * Math.sin(theta2);
                const Aterm = Math.cos(theta2) - k1 - k2 * Math.cos(theta2) + k3;

                const Theta4 = 2 * Math.atan(-Bterm - Math.sqrt(Math.pow(Bterm, 2) - 4 * Aterm * Cterm)) + Math.PI / 4;
                const xlink = params.cLength * Math.cos(Theta4) + m2x;
                const ylink = params.cLength * Math.sin(Theta4) + m2y;

                //find the radius of the wheel center to the linkage
                const m3radius = Math.sqrt(Math.pow(xlink - params.m3centerx, 2) + Math.pow(ylink - params.m3centery, 2)); 
                const wheelangle = Math.asin((ylink - params.m3centery) / m3radius);
                const wheelRotated = wheelangle + (t / params.M3Period) * 2 * Math.PI;

                const xpen = m3radius * Math.cos(wheelRotated) + params.m3centerx;
                const ypen = m3radius * Math.sin(wheelRotated) + params.m3centery;

                // Append points for drawing
                XPointList.push(xpen);
                YPointList.push(ypen);
                
                t += 1; // Time step
            }
            return { XPointList, YPointList };
        }

        // Function to get all input values (parameters) from the controls
        function getParameters() {
            const parameters = {};
            const inputs = document.querySelectorAll('.controls input');
            inputs.forEach(input => {
                parameters[input.id] = parseFloat(input.value);
            });
            return parameters;
        }

        function generateSVGContent(parameters) {
            const { XPointList, YPointList } = generatePatternPoints(parameters);
            const svgWidth = 600;  // Match the container size
            const svgHeight = 600; // Match the container size

            if (isFirstRender) {
                // Calculate initial normalization values
                const xmin = Math.min(...XPointList);
                const xmax = Math.max(...XPointList);
                const ymin = Math.min(...YPointList);
                const ymax = Math.max(...YPointList);

                // Calculate pattern dimensions
                const patternWidth = xmax - xmin;
                const patternHeight = ymax - ymin;

                // Calculate scaling factors to fit the SVG viewBox
                const scaleX = (svgWidth * 0.9) / patternWidth;  // Leave 10% margin
                const scaleY = (svgHeight * 0.9) / patternHeight; // Leave 10% margin
                globalScale = Math.min(scaleX, scaleY); // To maintain aspect ratio

                // Calculate shifts to center the pattern
                globalShiftX = (svgWidth / globalScale - patternWidth) / 2 - xmin;
                globalShiftY = (svgHeight / globalScale - patternHeight) / 2 - ymin;

                isFirstRender = false;
            }

            // Apply the stored transformations
            const transformedXPoints = XPointList.map(x => (x + globalShiftX) * globalScale);
            const transformedYPoints = YPointList.map(y => (y + globalShiftY) * globalScale);

            // Generate SVG content
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="xMidYMid meet">\n`;

            // Metadata comments for parameters
            svgContent += `<!-- Parameters used to generate this file\n`;
            for (const [key, value] of Object.entries(parameters)) {
                svgContent += `<${key}="${value}" />\n`;
            }
            svgContent += `-->\n`;

            // Create the path with transformed points
            svgContent += `<path d="M ${transformedXPoints[0]} ${transformedYPoints[0]} `;
            for (let i = 1; i < transformedXPoints.length; i++) {
                svgContent += `L ${transformedXPoints[i].toFixed(2)} ${transformedYPoints[i].toFixed(2)} `;
            }
            svgContent += `" fill="none" stroke="black" stroke-width="0.5"/>\n`;

            svgContent += `</svg>`;
            return svgContent;
        }

        // Function to save the SVG file
        function saveSVG() {
            const parameters = getParameters(); // Get current parameter values
            const svgContent = generateSVGContent(parameters); // Generate SVG content with metadata

            // Create a blob from the SVG content and download it as a file
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link and trigger the download
            const link = document.createElement('a');
            link.href = url;
            link.download = 'guilloche_pattern.svg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Attach saveSVG to the save button
        document.getElementById('saveButton').addEventListener('click', saveSVG);

        //
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, generating initial pattern');
            setTimeout(() => {
                generatePattern();
            }, 100); // Small delay to ensure everything is ready
        });

        // Add these functions to your script section
        function loadSVG() {
            document.getElementById('fileInput').click();
        }

        function parseSVGParameters(svgContent) {
            // Extract the parameters from the comment
            const paramMatch = svgContent.match(/<!-- Parameters used to generate this file\n([\s\S]*?)-->/);
            if (!paramMatch) return null;

            const paramText = paramMatch[1];
            const params = {};
            
            // Parse each parameter line
            const paramLines = paramText.split('\n');
            paramLines.forEach(line => {
                const match = line.match(/<(\w+)="([^"]+)"/);
                if (match) {
                    const [_, key, value] = match;
                    params[key] = parseFloat(value);
                }
            });
            
            return params;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const svgContent = e.target.result;
                const params = parseSVGParameters(svgContent);
                
                if (params) {
                    // Update all input fields with the loaded parameters
                    Object.entries(params).forEach(([key, value]) => {
                        const input = document.getElementById(key);
                        if (input) {
                            input.value = value;
                        }
                    });
                    
                    // Generate the pattern with the new parameters
                    generatePattern();
                } else {
                    alert('Could not find valid parameters in the SVG file');
                }
            };
            reader.readAsText(file);
        }

        // Add these event listeners after your existing ones
        document.getElementById('loadButton').addEventListener('click', loadSVG);
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

    </script>
</body>
</html>
