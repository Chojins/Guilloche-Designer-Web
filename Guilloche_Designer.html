<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Guilloche Pattern Generator</title>
<style>
    body {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        font-family: Arial, sans-serif;
    }

    h1 {
        width: 100%;
        text-align: center;
        margin: 20px 0;
        font-size: 2em;
    }

    .container {
        display: flex;
        align-items: flex-start; /* Aligns controls to the top of the canvas */
        gap: 20px;
        width: 90%;
    }

    .controls {
        display: flex;
        flex-direction: column;
        width: 300px;
        max-width: 300px;
    }

    .control-group {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }

    .control-group label {
        width: 120px;
    }

    .control-group input {
        width: 60px;
        margin-right: 5px;
    }

    .control-group button {
        margin: 0 2px;
    }

    #canvasContainer {
        flex: 1;
    }

    /* Style for the canvas */
    #patternCanvas {
        border: 1px solid #ccc;
    }

    #svgContainer {
        flex: 1;
        width: 600px;  /* Set a specific width */
        height: 600px; /* Set a specific height */
    }

    #svgContainer svg {
        width: 100%;
        height: 100%;
        background-color: white;
    }

</style>
</head>
<body>

<h1>Guilloche Pattern Generator</h1>

<div class="container">
    <div class="controls">
        <div class="control-group">
                <label for="m1centerx">M1 center x:</label>
                <input type="number" id="m1centerx" value="0" step="1" />
                <button data-id="m1centerx" data-delta="1">+</button>
                <button data-id="m1centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m1centery">M1 center y:</label>
                <input type="number" id="m1centery" value="600" step="1" />
                <button data-id="m1centery" data-delta="1">+</button>
                <button data-id="m1centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M1Period">M1 Period:</label>
                <input type="number" id="M1Period" value="299" step="1" />
                <button data-id="M1Period" data-delta="1">+</button>
                <button data-id="M1Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m2centerx">M2 center x:</label>
                <input type="number" id="m2centerx" value="210" step="1" />
                <button data-id="m2centerx" data-delta="1">+</button>
                <button data-id="m2centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m2centery">M2 center y:</label>
                <input type="number" id="m2centery" value="600" step="1" />
                <button data-id="m2centery" data-delta="1">+</button>
                <button data-id="m2centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M2Period">M2 Period:</label>
                <input type="number" id="M2Period" value="302" step="1" />
                <button data-id="M2Period" data-delta="1">+</button>
                <button data-id="M2Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m3centerx">M3 center x:</label>
                <input type="number" id="m3centerx" value="0" step="1" />
                <button data-id="m3centerx" data-delta="1">+</button>
                <button data-id="m3centerx" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="m3centery">M3 center y:</label>
                <input type="number" id="m3centery" value="260" step="1" />
                <button data-id="m3centery" data-delta="1">+</button>
                <button data-id="m3centery" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="M3Period">M3 Period:</label>
                <input type="number" id="M3Period" value="600" step="1" />
                <button data-id="M3Period" data-delta="1">+</button>
                <button data-id="M3Period" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="Iterations">Iterations:</label>
                <input type="number" id="Iterations" value="20000" step="10" />
                <button data-id="Iterations" data-delta="10">+</button>
                <button data-id="Iterations" data-delta="-10">-</button>
            </div>
            <div class="control-group">
                <label for="aLength">aLength:</label>
                <input type="number" id="aLength" value="30" />
                <button data-id="aLength" data-delta="1">+</button>
                <button data-id="aLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="bLength">bLength:</label>
                <input type="number" id="bLength" value="340" />
                <button data-id="bLength" data-delta="1">+</button>
                <button data-id="bLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="cLength">cLength:</label>
                <input type="number" id="cLength" value="400" />
                <button data-id="cLength" data-delta="1">+</button>
                <button data-id="cLength" data-delta="-1">-</button>
            </div>
            <div class="control-group">
                <label for="dLength">dLength:</label>
                <input type="number" id="dLength" value="30" />
                <button data-id="dLength" data-delta="1">+</button>
                <button data-id="dLength" data-delta="-1">-</button>
            </div>
        
            <button id="generateButton" onclick="generatePattern()">Generate Pattern</button>
            <button id="saveButton">Save SVG</button>
        </div>
    
        <!-- Placeholder for dynamically generated SVG -->
        <div id="svgContainer"></div>

    </div>

    <script>

        let offsetX = 0, offsetY = 0; // Initial canvas position offset
        let scale = 1; // Initial zoom scale
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        document.getElementById("generateButton").addEventListener("click", generatePattern);

        function adjustValue(id, delta) {
            const input = document.getElementById(id);
            input.value = parseFloat(input.value) + delta;
            generatePattern();
        }

        document.querySelectorAll('.control-group button').forEach(button => {
            const id = button.getAttribute('data-id');
            const delta = parseFloat(button.getAttribute('data-delta'));
            
            let isAdjusting = false;
            let lastUpdateTime = 0;
            const updateInterval = 100; // Faster repeat rate (10 times per second)
            let animationFrameId = null;
            let holdStartTime = 0;
            const holdDelay = 500; // Keep 500ms delay before starting continuous updates

            function updateValue(timestamp) {
                if (isAdjusting) {
                    // Only start continuous updates after holding for holdDelay
                    if (timestamp - holdStartTime >= holdDelay) {
                        // Then only update if enough time has passed
                        if (timestamp - lastUpdateTime >= updateInterval) {
                            adjustValue(id, delta);
                            lastUpdateTime = timestamp;
                        }
                        animationFrameId = requestAnimationFrame(updateValue);
                    } else {
                        animationFrameId = requestAnimationFrame(updateValue);
                    }
                }
            }

            button.addEventListener('mousedown', () => {
                isAdjusting = true;
                holdStartTime = performance.now();
                lastUpdateTime = 0;
                // Immediate single adjustment on click
                adjustValue(id, delta);
                // Start watching for hold
                updateValue(performance.now());
            });

            const stopAdjusting = () => {
                isAdjusting = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            };

            button.addEventListener('mouseup', stopAdjusting);
            button.addEventListener('mouseleave', stopAdjusting);
            window.addEventListener('mouseup', stopAdjusting);
        });

        function generatePattern() {
            parameters = getParameters()
            const { XPointList, YPointList } = generatePatternPoints(parameters);
            displayPatternAsSVG(parameters)
        }

        // Add this after the generatePattern function
        // Add enter key handler to all input fields
        document.querySelectorAll('.controls input').forEach(input => {
            input.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    generatePattern();
                }
            });
        });

        function displayPatternAsSVG(parameters) {
            // Add console log to debug
            console.log('Generating SVG with parameters:', parameters);

            // Generate SVG content
            const svgContent = generateSVGContent(parameters);
            console.log('SVG content generated:', svgContent.substring(0, 100) + '...'); // Log first 100 chars

            // Replace canvas with SVG
            const svgContainer = document.getElementById("svgContainer");
            svgContainer.innerHTML = svgContent;
        }

        // Function to generate the Guilloche pattern and return the points
        function generatePatternPoints(params) {

            let XPointList = [];
            let YPointList = [];
            let t = 0;

            // Periodic motors' calculations and drawing
            for (let i = 0; i < params.Iterations; i++) {
                
                const theta2 = 2 * Math.PI * (t / params.M1Period);

                const mdist = Math.sqrt(Math.pow(params.m2centerx - params.m1centerx, 2) + Math.pow(params.m2centery - params.m1centery, 2));

                const k1 = mdist / params.aLength;
                const k2 = mdist / params.cLength;
                const k3 = (Math.pow(params.aLength, 2) + Math.pow(params.cLength, 2) + Math.pow(mdist, 2) - Math.pow(params.bLength, 2)) / (2 * params.aLength * params.cLength);
                
                //calculate the motor positions
                const m1x = params.aLength * Math.cos(theta2) + params.m1centerx;
                const m1y = params.aLength * Math.sin(theta2) + params.m1centery;
                const m2x = -params.dLength * Math.cos(2 * Math.PI * (t / params.M2Period)) + params.m2centerx;
                const m2y = -params.dLength * Math.sin(2 * Math.PI * (t / params.M2Period)) + params.m2centery;


                // Calculate linkage
                const Cterm = k1 - (k2 + 1) * Math.cos(theta2) + k3;
                const Bterm = -2 * Math.sin(theta2);
                const Aterm = Math.cos(theta2) - k1 - k2 * Math.cos(theta2) + k3;

                const Theta4 = 2 * Math.atan(-Bterm - Math.sqrt(Math.pow(Bterm, 2) - 4 * Aterm * Cterm)) + Math.PI / 4;
                const xlink = params.cLength * Math.cos(Theta4) + m2x;
                const ylink = params.cLength * Math.sin(Theta4) + m2y;

                //find the radius of the wheel center to the linkage
                const m3radius = Math.sqrt(Math.pow(xlink - params.m3centerx, 2) + Math.pow(ylink - params.m3centery, 2)); 
                const wheelangle = Math.asin((ylink - params.m3centery) / m3radius);
                const wheelRotated = wheelangle + (t / params.M3Period) * 2 * Math.PI;

                const xpen = m3radius * Math.cos(wheelRotated) + params.m3centerx;
                const ypen = m3radius * Math.sin(wheelRotated) + params.m3centery;

                // Append points for drawing
                XPointList.push(xpen);
                YPointList.push(ypen);
                
                t += 1; // Time step
            }
            return { XPointList, YPointList };
        }

        // Function to plot the Guilloche pattern points on the canvas
        function plotPatternToCanvas(XPointList, YPointList) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate bounds
            const minX = Math.min(...XPointList);
            const maxX = Math.max(...XPointList);
            const minY = Math.min(...YPointList);
            const maxY = Math.max(...YPointList);

            // Calculate scale and offset to fit the pattern in the canvas
            const patternWidth = maxX - minX;
            const patternHeight = maxY - minY;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            const scaleX = canvasWidth / patternWidth;
            const scaleY = canvasHeight / patternHeight;
            const scale = Math.min(scaleX, scaleY) * 0.9; // Slight padding

            const offsetX = (canvasWidth - patternWidth * scale) / 2 - minX * scale;
            const offsetY = (canvasHeight - patternHeight * scale) / 2 - minY * scale;

            // Draw the pattern on canvas
            ctx.beginPath();
            ctx.moveTo(XPointList[0] * scale + offsetX, YPointList[0] * scale + offsetY);
            for (let i = 1; i < XPointList.length; i++) {
                ctx.lineTo(XPointList[i] * scale + offsetX, YPointList[i] * scale + offsetY);
            }
            ctx.stroke();
        }

        // Function to get all input values (parameters) from the controls
        function getParameters() {
            const parameters = {};
            const inputs = document.querySelectorAll('.controls input');
            inputs.forEach(input => {
                parameters[input.id] = parseFloat(input.value);
            });
            return parameters;
        }

        function generateSVGContent(parameters) {
            const { XPointList, YPointList } = generatePatternPoints(parameters);
            const svgWidth = 800;  // Increased SVG viewBox width
            const svgHeight = 800; // Increased SVG viewBox height

            // Calculate normalization shifts
            const xmin = Math.min(...XPointList);
            const ymin = Math.min(...YPointList);
            const shiftx = -xmin;
            const shifty = -ymin;

            // Apply shifts
            const shiftedXPoints = XPointList.map(x => x + shiftx);
            const shiftedYPoints = YPointList.map(y => y + shifty);

            // Calculate pattern width and height after shifting
            const patternWidth = Math.max(...shiftedXPoints);
            const patternHeight = Math.max(...shiftedYPoints);

            // Calculate scaling factors to fit the SVG viewBox
            const scaleX = svgWidth / patternWidth;
            const scaleY = svgHeight / patternHeight;
            const scale = Math.min(scaleX, scaleY); // To maintain aspect ratio

            // Scale points to fit within the SVG viewBox dimensions
            const scaledXPoints = shiftedXPoints.map(x => x * scale);
            const scaledYPoints = shiftedYPoints.map(y => y * scale);

            // SVG content start
            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 ${svgWidth} ${svgHeight}" preserveAspectRatio="xMidYMid meet">\n`;

            // Metadata comments for parameters
            svgContent += `<!-- Parameters used to generate this file\n`;
            for (const [key, value] of Object.entries(parameters)) {
                svgContent += `<${key}="${value}" />\n`;
            }
            svgContent += `-->\n`;

            // Begin the path data with normalized and scaled points
            svgContent += `<path d="M ${scaledXPoints[0]} ${scaledYPoints[0]} `;
            for (let i = 1; i < scaledXPoints.length; i++) {
                svgContent += `L ${scaledXPoints[i].toFixed(2)} ${scaledYPoints[i].toFixed(2)} `;
            }
            svgContent += `" fill="none" stroke="black" stroke-width="0.5"/>\n`;

            // Close SVG
            svgContent += `</svg>`;

            return svgContent;
        }


        // Function to save the SVG file
        function saveSVG() {
            const parameters = getParameters(); // Get current parameter values
            const svgContent = generateSVGContent(parameters); // Generate SVG content with metadata

            // Create a blob from the SVG content and download it as a file
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link and trigger the download
            const link = document.createElement('a');
            link.href = url;
            link.download = 'guilloche_pattern.svg';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Attach saveSVG to the save button
        document.getElementById('saveButton').addEventListener('click', saveSVG);


        // Replace the existing generatePattern() call at the bottom with this:
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, generating initial pattern');
            setTimeout(() => {
                generatePattern();
            }, 100); // Small delay to ensure everything is ready
        });

    </script>
</body>
</html>
